## ✒️算法
 

  * [数字游戏](#%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F)
    * [随机数](#%E9%9A%8F%E6%9C%BA%E6%95%B0)
    * [频率](#%E9%A2%91%E7%8E%87)
  * [Hash](#hash)
    * [哈希函数](#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0)
    * [哈希冲突处理](#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86)
  * [排序算法](#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)
    * [插入排序](#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)
    * [选择排序](#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)
    * [交换排序](#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F)
    * [其他排序](#%E5%85%B6%E4%BB%96%E6%8E%92%E5%BA%8F)


### 数字游戏
+ [水仙花数](/Interview-.NET/Subject/算法/Narcissus.cs)
+ [约瑟夫问题](/Interview-.NET/Subject/算法/Josephus.cs)
+ [斐波那契数列](/Interview-.NET/Subject/算法/Fibonacci.cs)
+ [交换 a b 的值](/Interview-.NET/Subject/算法/Swap.cs)

#### 随机数
+ [1-100的随机数](/Interview-Java/src/test/java/Algorithm/RandomNum.java#L16)
```
// Java：randNumber 将被赋值为一个 MIN 和 MAX 范围内的随机数
int randNumber = new Random().nextInt(MAX - MIN + 1) + MIN;
```
```
// C#：randNumber 将被赋值为一个 MIN 和 MAX 范围内的随机数
int randNumber = new Random().Next(MIN, MAX + 1); 
```
+ [随机数字和字母](/Interview-Java/src/test/java/Algorithm/RandomNum.java#L37)

#### 频率
+ [100个URL如何找到出现频率最高的前10个](/Interview-Java/src/test/java/Algorithm/MaxUrl.java)
+ [获取一个字符串在另一个字符串中出现的次数](/Interview-Java/src/test/java/Algorithm/Stringsub.java)
 
### Hash 
#### 哈希函数
+ 直接取余法：f(x):= x mod maxM ; maxM一般是不太接近 2^t 的一个质数。
+ 乘法取整法：f(x):=trunc((x/maxX)\*maxlongit) mod maxM，主要用于实数。
+ 平方取中法：f(x):=(x*x div 1000 ) mod 1000000); 平方后取中间的，每位包含信息比较多。

#### 哈希冲突处理
+ 开放寻址法：把所有的元素都存放在散列表中，也就是每个表项包含动态集合的一个元素，或者包含NIL。
+ 再散列法：即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生。
  + 不易产生“聚集”；
  + 增加了计算时间。
+ 链地址法（拉链法）
+ 公共溢出区  
 
### 排序算法  
![排序时间复杂度](http://img.my.csdn.net/uploads/201207/19/1342700879_2982.jpg)

#### 插入排序
+ 直接插入排序
  + 基本思想：将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。
  + 设立哨兵，作为临时存储和判断数组边界之用。  
  ![直接插入排序](http://img.my.csdn.net/uploads/201207/17/1342520948_8667.jpg)

+ 希尔排序（缩小增量排序）
  + 基本思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。  
  ![希尔排序](http://img.my.csdn.net/uploads/201207/18/1342577299_5077.jpg)

#### 选择排序
+ 直接选择排序
  + 基本思想：在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。  
  ![选择排序](http://img.my.csdn.net/uploads/201207/18/1342586432_7130.jpg)
  
+ 堆排序
  + 是一种树形选择排序，是对直接选择排序的有效改进。

#### 交换排序
+ 冒泡排序
  + 基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。
  + 改进：
    1) 加入标志性变量exchange，用于标志某一趟排序过程中是否有数据交换。
    2) 设置一标志性变量pos，用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到pos位置即可。
    3) 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值，我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) ，从而使排序趟数几乎减少了一半。  
  ![冒泡排序](http://img.my.csdn.net/uploads/201207/20/1342782078_9990.jpg)
```
    void bubbleSort(int a[], int n){  
        for(int i =0 ; i< n-1; ++i) {  
            for(int j = 0; j < n-i-1; ++j) {  
                if(a[j] > a[j+1])  
                {  
                    int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;  
                }  
            }  
        }  
    }  
```

+ 快速排序
  + 基本思想：
    1) 选择一个基准元素，通常选择第一个元素或者最后一个元素；
    2) 通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小，另一部分记录的元素值比基准值大；
    3) 此时基准元素在其排好序后的正确位置；
    4) 然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。
  + 改进：
    1) 三者取中法：排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。  
  ![快速排序](http://img.my.csdn.net/uploads/201207/20/1342782329_8314.jpg)

#### 其他排序
+ 归并排序
  + 基本思想：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。  
  ![归并排序](http://img.my.csdn.net/uploads/201207/21/1342842633_6751.jpg)

+ 桶排序
  + 基本思想：就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。  

+ 基数排序

### 其他
+ [球面距离公式](https://baike.baidu.com/item/%E7%90%83%E9%9D%A2%E8%B7%9D%E7%A6%BB%E5%85%AC%E5%BC%8F/5374455?fr=aladdin)
```
S=R·arc cos[cosβ1cosβ2cos（α1-α2）+sinβ1sinβ2]
```





